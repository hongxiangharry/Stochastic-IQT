# @Github Repo: https://github.com/hongxiangharry/Stochastic-IQT
# @Citation: Lin, H., Figini, M., D'Arco, F., Ogbole, G., Tanno, R., Blumberg, S. B., ... ,and Alexander, D. C. (2023).
# Low-field magnetic resonance image enhancement via stochastic image quality transfer. Medical Image Analysis, 87, 102807.
# @ Please cite the above paper if you feel this code useful for your research.
#
# MIT License
#
# Copyright (c) 2023 Hongxiang Lin <harryhxlin@gmail.com>. All Rights Reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# This code was derived from an initial Matlab version programmed by Dr. Matteo Figini (m.figini@ucl.ac.uk).
# @Citation: Figini, Matteo, Lin, Hongxiang, et al. "Image quality transfer enhances contrast and resolution of low-field
#  brain mri in african paediatric epilepsy patients." arXiv:2003.07216 (2020).
#
""" Low-field MR image simulator through intensity translation. """

from utils.ioutils import read_volume_data, read_volume
import os
import numpy as np
import nibabel as nib
from nibabel.processing import resample_from_to, smooth_image
from numpy.random import normal

def read_volume_and_mask(imfile) :
    im_nii = read_volume_data(imfile) # header + data
    im = read_volume(imfile) # data

    scl_slope = im_nii.header['scl_slope']
    scl_inter = im_nii.header['scl_inter']

    if scl_slope != 0 and not np.isnan(scl_slope):
        im = im*scl_slope+scl_inter
    return im

def MRI_036T_sim_contrast_custom(imdir,
                                imfile,
                                outdir,
                                outfile,
                                SNR_WM,
                                SNR_GM,
                                ds_factors,
                                gaps,
                                suffix = None,
                                mask_thres = 0.9,
                                is_save_masked_groundtruth = False,
                                savegroundtruth_path = None,
                                i_shape_org = None,
                                is_upsample = False,
                                is_sim_WM_fixed = True):
    '''
    Simulate low-field MRI for training IQT model. Change the contrast by adapting the white matter (WM) and grey matter
     (GM) SNRs. Downsample image at slice direction with downsampling factor and gap.

    :param imdir: image directory including the MRI files and masks. Masks are generated by SPM12. Prefixes 'c1', 'c2',
    'c3' are referred to GM, WM and CSF.
    :param imfile: image file name.
    :param outdir: output image directory
    :param SNR_WM: white matter SNR
    :param SNR_GM: grey matter SNR
    :param ds_factors: downsampling factor, e.g. [1, 1, 3]
    :param gaps: gap between thick slices, e.g. [0, 0, 1]
    :param suffix: suffix of output file name, following imfile
    :param mask_thres: threshold of probability mask to actually identify tissue type
    :param is_save_masked_groundtruth: determine if saving a masked ground-truth image
    :param savegroundtruth_path: specify the save path of gt, none for by default saving under imdir.
    :param is_sim_WM_fixed: fix WM or GM contrast, True for fixed WM, False for fixed GM
    :return:
    '''

    # filepath_templ = os.path.join(imdir, '{}'+imfile)
    # im = nib.load(filepath_templ.format(''))
    #
    # GM = nib.load(filepath_templ.format('c1'))
    # WM = nib.load(filepath_templ.format('c2'))
    # CSF = nib.load(filepath_templ.format('c3'))


    # 2021-iqt update 1: mask name has been changed.
    filepath_templ = os.path.join(imdir, '{}')
    im = nib.load(filepath_templ.format(imfile))

    if os.path.isfile(filepath_templ.format('c1' + imfile)):
        GM = nib.load(filepath_templ.format('c1' + imfile))
    else:
        GM = nib.load(filepath_templ.format('c1T1brain.nii'))

    if os.path.isfile(filepath_templ.format('c2' + imfile)):
        WM = nib.load(filepath_templ.format('c2' + imfile))
    else:
        WM = nib.load(filepath_templ.format('c2T1brain.nii'))

    if os.path.isfile(filepath_templ.format('c3' + imfile)):
        CSF = nib.load(filepath_templ.format('c3' + imfile))
    else:
        CSF = nib.load(filepath_templ.format('c3T1brain.nii'))

    tds_factors = np.array(ds_factors)+np.array(gaps) # total ds factor at each dim

    # 2021-iqt update 2: remove some slices
    if i_shape_org is None:
        i_shape_org = im.shape
    i_shape = np.floor(np.array(i_shape_org) // tds_factors).astype(np.int64)  # downsampled shape of output


    i_affine = im.affine
    i_affine_org = im.affine
    im_data = im.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    im = nib.Nifti1Image(im_data, affine=i_affine)
    gm_data = GM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    GM = nib.Nifti1Image(gm_data, affine=i_affine)
    wm_data = WM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    WM = nib.Nifti1Image(wm_data, affine=i_affine)
    csf_data = CSF.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    CSF = nib.Nifti1Image(csf_data, affine=i_affine)

    ## smoothing by Gaussian filter
    fwhm = np.array(im.header.get_zooms()) \
         * np.array(ds_factors) \
         * (np.array(ds_factors)!=1) # fwhm for Gaussian filter
    im = smooth_image(im, fwhm)
    GM = smooth_image(GM, fwhm)
    WM = smooth_image(WM, fwhm)
    CSF = smooth_image(CSF, fwhm)

    ## downsample: can just simply use resample_from_to
    i_affine = np.dot(im.affine, np.diag(tds_factors.tolist() + [1]))  # affine rescaling
    # i_shape = np.floor( np.array(im.shape) // tds_factors ).astype(np.int64) # downsampled shape of output
    im = resample_from_to(im, (i_shape, i_affine)) # resize
    GM = resample_from_to(GM, (i_shape, i_affine)) # resize
    WM = resample_from_to(WM, (i_shape, i_affine)) # resize
    CSF = resample_from_to(CSF, (i_shape, i_affine)) # resize

    ## adapt LF SNR
    im_data = im.get_data()

    if is_sim_WM_fixed is True: # fixed WM
        sigma = np.mean(im_data[WM.get_data()>mask_thres])/SNR_WM #  = new background noise; WM_new = WM_old
        newGM = SNR_GM * sigma # new GM intensity
        im_data = (WM.get_data()+newGM*GM.get_data()/np.mean(im_data[GM.get_data()>mask_thres])+CSF.get_data())*im_data
    else: # fixed GM
        sigma = np.mean(im_data[GM.get_data() > mask_thres]) / SNR_GM  # = new background noise; GM_new = GM_old
        newWM = SNR_WM * sigma  # new WM intensity
        im_data = (GM.get_data() + newWM * WM.get_data() / np.mean(
            im_data[WM.get_data() > mask_thres]) + CSF.get_data()) * im_data

    ## add additive random noise
    im_data_noise = im_data + sigma*normal(size=im_data.shape)

        ## rewrite suffix
    if suffix is None:
        suffix = '_WM{:.2f}_GM{:.2f}'.format(SNR_WM, SNR_GM)

    ## save nii
    im = nib.Nifti1Image(im_data_noise, affine=i_affine)

    ## iqt-21 update: upsample the downsampled im for isoUNet or others
    if is_upsample == True:
        im = resample_from_to(im, (i_shape_org, i_affine_org))

    if outfile is None:
        out_filepath = os.path.join(outdir, imfile[:-7]+ \
                        '_sim036T_{}x{}'.format(np.prod(tds_factors),suffix)+ \
                        '.nii.gz')
    else:
        out_filepath = os.path.join(outdir, outfile)
    out_foldername = os.path.dirname(out_filepath)
    if not os.path.isdir(out_foldername) :
        os.makedirs(out_foldername)
    nib.save(im, out_filepath)

    ## todo: save masks

    ## save gt
    if savegroundtruth_path is not None:
        out_gt_filepath = os.path.join(outdir, savegroundtruth_path)
    else:
        out_gt_filepath = os.path.join(outdir, imfile[:-7]+ \
                        '_sim036T_{}x{}'.format(np.prod(tds_factors), '_groundtruth')+ \
                        '.nii.gz')
    if not os.path.isfile(out_gt_filepath):
        i_shape_org = i_shape * tds_factors ## update at 23/05/15
        im = nib.load(filepath_templ.format(imfile))
        i_affine = im.affine
        im_data = im.get_data()
        im_data = im_data[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]

        if is_save_masked_groundtruth is True:
            if os.path.isfile(filepath_templ.format('c1' + imfile)):
                GM = nib.load(filepath_templ.format('c1' + imfile))
            else:
                GM = nib.load(filepath_templ.format('c1T1brain.nii'))

            if os.path.isfile(filepath_templ.format('c2' + imfile)):
                WM = nib.load(filepath_templ.format('c2' + imfile))
            else:
                WM = nib.load(filepath_templ.format('c2T1brain.nii'))

            if os.path.isfile(filepath_templ.format('c3' + imfile)):
                CSF = nib.load(filepath_templ.format('c3' + imfile))
            else:
                CSF = nib.load(filepath_templ.format('c3T1brain.nii'))
            gm_data = GM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
            wm_data = WM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
            csf_data = CSF.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
            im_data = (gm_data+wm_data+csf_data) * im_data

        im = nib.Nifti1Image(im_data, affine=i_affine)
        nib.save(im, out_gt_filepath)

    return True


def MRI_036T_sim_contrast_custom_old(imdir,
                                imfile,
                                outdir,
                                outfile,
                                SNR_WM,
                                SNR_GM,
                                ds_factors,
                                gaps,
                                suffix = None,
                                mask_thres = 0.9,
                                is_save_masked_groundtruth = False,
                                savegroundtruth_path = None,
                                i_shape_org = None,
                                is_upsample = False):
    '''
    Simulate low-field MRI for training IQT model. Change the contrast by adapting the white matter (WM) and grey matter
     (GM) SNRs. Downsample image at slice direction with downsampling factor and gap.

    :param imdir: image directory including the MRI files and masks. Masks are generated by SPM12. Prefixes 'c1', 'c2',
    'c3' are referred to GM, WM and CSF.
    :param imfile: image file name.
    :param outdir: output image directory
    :param SNR_WM: white matter SNR
    :param SNR_GM: grey matter SNR
    :param ds_factors: downsampling factor, e.g. [1, 1, 3]
    :param gaps: gap between thick slices, e.g. [0, 0, 1]
    :param suffix: suffix of output file name, following imfile
    :param mask_thres: threshold of probability mask to actually identify tissue type
    :param is_save_masked_groundtruth: determine if saving a masked ground-truth image
    :param savegroundtruth: done
    :param is
    :return:
    '''

    # filepath_templ = os.path.join(imdir, '{}'+imfile)
    # im = nib.load(filepath_templ.format(''))
    #
    # GM = nib.load(filepath_templ.format('c1'))
    # WM = nib.load(filepath_templ.format('c2'))
    # CSF = nib.load(filepath_templ.format('c3'))


    # 2021-iqt update 1: mask name has been changed.
    filepath_templ = os.path.join(imdir, '{}')
    im = nib.load(filepath_templ.format(imfile))

    if os.path.isfile(filepath_templ.format('c1' + imfile)):
        GM = nib.load(filepath_templ.format('c1' + imfile))
    else:
        GM = nib.load(filepath_templ.format('c1T1brain.nii'))

    if os.path.isfile(filepath_templ.format('c2' + imfile)):
        WM = nib.load(filepath_templ.format('c2' + imfile))
    else:
        WM = nib.load(filepath_templ.format('c2T1brain.nii'))

    if os.path.isfile(filepath_templ.format('c3' + imfile)):
        CSF = nib.load(filepath_templ.format('c3' + imfile))
    else:
        CSF = nib.load(filepath_templ.format('c3T1brain.nii'))

    tds_factors = np.array(ds_factors)+np.array(gaps) # total ds factor at each dim

    # 2021-iqt update 2: remove some slices
    if i_shape_org is None:
        i_shape_org = im.shape
    i_shape = np.floor(np.array(i_shape_org) // tds_factors).astype(np.int64)  # downsampled shape of output


    i_affine = im.affine
    i_affine_org = im.affine
    im_data = im.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    im = nib.Nifti1Image(im_data, affine=i_affine)
    gm_data = GM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    GM = nib.Nifti1Image(gm_data, affine=i_affine)
    wm_data = WM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    WM = nib.Nifti1Image(wm_data, affine=i_affine)
    csf_data = CSF.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
    CSF = nib.Nifti1Image(csf_data, affine=i_affine)

    ## smoothing by Gaussian filter
    fwhm = np.array(im.header.get_zooms()) \
         * np.array(ds_factors) \
         * (np.array(ds_factors)!=1) # fwhm for Gaussian filter
    im = smooth_image(im, fwhm)
    GM = smooth_image(GM, fwhm)
    WM = smooth_image(WM, fwhm)
    CSF = smooth_image(CSF, fwhm)

    ## downsample: can just simply use resample_from_to
    i_affine = np.dot(im.affine, np.diag(tds_factors.tolist() + [1]))  # affine rescaling
    # i_shape = np.floor( np.array(im.shape) // tds_factors ).astype(np.int64) # downsampled shape of output
    im = resample_from_to(im, (i_shape, i_affine)) # resize
    GM = resample_from_to(GM, (i_shape, i_affine)) # resize
    WM = resample_from_to(WM, (i_shape, i_affine)) # resize
    CSF = resample_from_to(CSF, (i_shape, i_affine)) # resize

    ## adapt LF SNR
    im_data = im.get_data()

    sigma = np.mean(im_data[WM.get_data()>mask_thres])/SNR_WM #  = new background noise; WM_new = WM_old
    newGM = SNR_GM * sigma # new GM intensity
    im_data = (WM.get_data()+newGM*GM.get_data()/np.mean(im_data[GM.get_data()>mask_thres])+CSF.get_data())*im_data

    ## add additive random noise
    im_data_noise = im_data + sigma*normal(size=im_data.shape)

        ## rewrite suffix
    if suffix is None:
        suffix = '_WM{:.2f}_GM{:.2f}'.format(SNR_WM, SNR_GM)

    ## save nii
    im = nib.Nifti1Image(im_data_noise, affine=i_affine)

    ## iqt-21 update: upsample the downsampled im for isoUNet or others
    if is_upsample == True:
        im = resample_from_to(im, (i_shape_org, i_affine_org))

    if outfile is None:
        out_filepath = os.path.join(outdir, imfile[:-7]+ \
                        '_sim036T_{}x{}'.format(np.prod(tds_factors),suffix)+ \
                        '.nii.gz')
    else:
        out_filepath = os.path.join(outdir, outfile)
    out_foldername = os.path.dirname(out_filepath)
    if not os.path.isdir(out_foldername) :
        os.makedirs(out_foldername)
    nib.save(im, out_filepath)

    ## todo: save masks

    ## save gt
    if savegroundtruth_path is not None:
        out_gt_filepath = os.path.join(outdir, savegroundtruth_path)
    else:
        out_gt_filepath = os.path.join(outdir, imfile[:-7]+ \
                        '_sim036T_{}x{}'.format(np.prod(tds_factors), '_groundtruth')+ \
                        '.nii.gz')
    if not os.path.isfile(out_gt_filepath):
        i_shape_org = i_shape * tds_factors ## update at 23/05/15
        im = nib.load(filepath_templ.format(imfile))
        i_affine = im.affine
        im_data = im.get_data()
        im_data = im_data[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]

        if is_save_masked_groundtruth is True:
            if os.path.isfile(filepath_templ.format('c1' + imfile)):
                GM = nib.load(filepath_templ.format('c1' + imfile))
            else:
                GM = nib.load(filepath_templ.format('c1T1brain.nii'))

            if os.path.isfile(filepath_templ.format('c2' + imfile)):
                WM = nib.load(filepath_templ.format('c2' + imfile))
            else:
                WM = nib.load(filepath_templ.format('c2T1brain.nii'))

            if os.path.isfile(filepath_templ.format('c3' + imfile)):
                CSF = nib.load(filepath_templ.format('c3' + imfile))
            else:
                CSF = nib.load(filepath_templ.format('c3T1brain.nii'))
            gm_data = GM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
            wm_data = WM.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
            csf_data = CSF.get_data()[:i_shape_org[0], :i_shape_org[1], :i_shape_org[2]]
            im_data = (gm_data+wm_data+csf_data) * im_data

        im = nib.Nifti1Image(im_data, affine=i_affine)
        nib.save(im, out_gt_filepath)

    return True
